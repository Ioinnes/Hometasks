1) map состоит из пар ключ/значение, причем ключ используется для поиска элемента, а значение содержит хранимую информацию. Телефонный справочник хорошо иллюстрирует понятие отображения: ключом является фамилия и имя абонента, а значением – его телефонный номер. 
Элемент контейнера set содержит только ключ, поэтому set эффективно реализует операцию проверки его существования. Этот контейнер можно применить, например, при реализации системы текстового поиска для хранения списка так называемых стоп-слов – слов, не используемых при поиске, таких, как и, или, не, так и тому подобных. Программа обработки текста считывает каждое слово и проверяет, есть ли оно в указанном списке. Если нет, то слово добавляется в базу данных.


2) идеальная хеш-функция: 
а) является детерминированной, то есть одно и то же сообщение приводит к одному и тому же хеш-значению
b) ее значение быстро вычисляется для любого сообщения
c) для нее невозможно найти сообщение, которое дает заданное хеш-значение
d) для нее невозможно найти два разных сообщения с одинаковым хеш-значением
e) для нее небольшое изменение в сообщении изменяет хеш настолько сильно, что новое и старое значения кажутся некоррелирующими

3) коллизии возникают из-за ограниченности значений хеш-фукнции. 
для разрешения коллизий в используются открытые хеш-таблицы и хеш-таблицы с цепочками.

4) вполне возможно, что все элементы будут иметь одинаковый хеш и нам придется либо просматривать весь список (метод цепочек)
либо, прогуляться по всем пробам (открытая адресация)

стоит отметить, что при вставке в хеш-таблицу размером 365 ячеек всего лишь 23 элементов вероятность коллизии уже превысит 50% (если каждый элемент может равновероятно попасть в любую ячейку) 

5)  он позволяет создавать контейнеры, поддерживающие один или несколько индексов с различной сортировкой и семантикой доступа. Индексы предоставляют интерфейсы, аналогичные интерфейсам контейнеров STL, что делает их использование привычным. Концепция мультииндексации по одному и тому же набору элементов заимствована из терминологии реляционных баз данных и позволяет определять сложные структуры данных в духе многоиндексированных реляционных таблиц, где простых наборов и отображений недостаточно. Предоставляется широкий выбор индексов, созданных по образцу аналогичных контейнеров STL, таких как std::set, std::list и std::unordered_set.

boost::MultiIndex обладает дополнительными функциональными возможностями, такими как поиск подобъектов, запрос диапазона, обновление элементов на месте и вычисление рангов, что делает его удобной заменой std::set и set::multiset, даже если возможности мультииндексации не требуются.
